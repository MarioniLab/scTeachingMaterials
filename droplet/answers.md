---
title: Analyzing single-cell RNA seq data from droplet-based protocols
author: Aaron Lun
date: "2018-08-26"
output: 
  BiocStyle::html_document:
    fig_caption: false
---



# Overview 

Droplet-based scRNA-seq protocols encapsulate cells in water-in-oil droplets for massively multiplexed library prepation.
We will be examining how to analyze this type of data, using a publicly available data set generated by 10X Genomics.
We assume that you have already taken the previous workshop describing the basics of scRNA-seq data analysis.

This worskshop will use R version 3.5.0 or higher, with a number of Bioconductor packages.
If you haven't downloaded and installed them already, you can do so by running the code below.
**This only needs to be done once** - the packages will be on your computer once installed, and can be loaded with `library`.


```r
source("https://bioconductor.org/biocLite.R")
biocLite(c("knitr", "BiocStyle", "EnsDb.Hsapiens.v86", "scater", 
    "Rtsne", "DropletUtils", "scran", "pheatmap"))
```

# Setting up the data

## Reading in a sparse matrix

We are using a data set containing 3000 T cells from a healthy human donor, see https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/t_3k.
The data have already been run through the _CellRanger_ pipeline to obtain unique molecular identifier (UMI) counts for each gene in each cell.

We load in the raw count matrix using the `read10xCounts()` function from the *[DropletUtils](http://bioconductor.org/packages/DropletUtils)* package.
This will create a `SingleCellExperiment` object where each column corresponds to a cell barcode.


```r
library(DropletUtils)
fname <- "t_3k/raw_gene_bc_matrices/GRCh38"
sce <- read10xCounts(fname, col.names=TRUE)
sce
```

```
## class: SingleCellExperiment 
## dim: 33694 737280 
## metadata(0):
## assays(1): counts
## rownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475
##   ENSG00000268674
## rowData names(2): ID Symbol
## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ...
##   TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1
## colData names(2): Sample Barcode
## reducedDimNames(0):
## spikeNames(0):
```

Here, each count represents the number of UMIs assigned to a gene for a cell barcode.
Note that the counts are loaded as a sparse matrix object - specifically, a `dgCMatrix` instance from the *[Matrix](https://CRAN.R-project.org/package=Matrix)* package.
This avoids allocating memory to hold zero counts.


```r
class(counts(sce))
```

```
## [1] "dgCMatrix"
## attr(,"package")
## [1] "Matrix"
```

<div class="alert alert-warning">
**Exercise:** 


```r
# How many non-zeroes are there?
mean(counts(sce)!=0)
```

```
## [1] 0.000289687
```


```r
# What is the difference in memory usage?
object.size(counts(sce))
```

```
## 156613864 bytes
```

```r
as.numeric(ncol(sce))*as.numeric(nrow(sce)) * 4
```

```
## [1] 99367649280
```


```r
# How can I get column sums?
library(Matrix)
head(colSums(counts(sce)))
```

```
## AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 AAACCTGAGAAACCTA-1 AAACCTGAGAAACGAG-1 
##                  0                  2                 22                  0 
## AAACCTGAGAAACGCC-1 AAACCTGAGAAAGTGG-1 
##                  0                  5
```

```r
head(Matrix::colSums(counts(sce)))
```

```
## AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 AAACCTGAGAAACCTA-1 AAACCTGAGAAACGAG-1 
##                  0                  2                 22                  0 
## AAACCTGAGAAACGCC-1 AAACCTGAGAAAGTGG-1 
##                  0                  5
```
</div>

## Annotating the rows

We relabel the rows with the gene symbols for easier reading using the `uniquifyFeatureNames()` function.


```r
library(scater)
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ID, rowData(sce)$Symbol)
head(rownames(sce))
```

```
## [1] "RP11-34P13.3"  "FAM138A"       "OR4F5"         "RP11-34P13.7" 
## [5] "RP11-34P13.8"  "RP11-34P13.14"
```

We also identify the chromosomal location for each gene, especially the mitochondrial location as this is particularly useful for later quality control.


```r
library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86, keys=rowData(sce)$ID, 
    column="SEQNAME", keytype="GENEID")
rowData(sce)$CHR <- location
summary(location=="MT")
```

```
##    Mode   FALSE    TRUE    NA's 
## logical   33537      13     144
```

# Calling cells from empty droplets

In droplet-based data, we don't know which droplets actually contain cells and which droplets are empty.
We need to call cells from empty droplets based on the observed expression profiles, which is not always easy due to the presence of extracellular RNA in empty droplets.
A good place to start is to examine a "barcode rank" plot:


```r
br.out <- barcodeRanks(counts(sce))
plot(br.out$rank, br.out$total, log="xy", xlab="Rank", ylab="Total count")
abline(h=br.out$inflection, col="forestgreen")
abline(h=br.out$knee, col="dodgerblue")
legend("bottomleft", legend=c("inflection", "knee"),
	col=c("forestgreen", "dodgerblue"), lwd=2)
```

<img src="answers_files/figure-html/unnamed-chunk-9-1.png" width="100%" />

We should see a sharp drop, above which are presumably cells (high RNA content) and below which are empty droplets (low RNA content).
We could draw some horizontal line to use as a threshold for defining cells, which is pretty much what _CellRanger_ does.

A more objective approach is implemented in the `emptyDrops()` function (see https://www.biorxiv.org/content/early/2018/04/04/234872).
This tests whether the expression profile for each cell barcode is significantly different from the ambient pool.
Any significant deviation indicates that the barcode corresponds to a cell-containing droplet.

We call cells at a false discovery rate (FDR) of 1%, meaning that no more than 1% of our called barcodes should be empty droplets on average.


```r
set.seed(100)
e.out <- emptyDrops(counts(sce))
sig <- e.out$FDR <= 0.01
sum(sig, na.rm=TRUE)
```

```
## [1] 3895
```

We can look at how the likelihoods (of originating from the ambient pool) _decrease_ with increasing total UMI count.
Note that the negative log-probabilities are plotted below, which _increase_ with increasing total count.


```r
plot(e.out$Total, -e.out$LogProb, log="xy", col=ifelse(sig, "red", "black"),
	xlab="Total count", ylab="-Log probability")
legend("topleft", legend=c("Putative cell", "Empty"), 
	col=c("red", "black"), pch=16)
```

<img src="answers_files/figure-html/unnamed-chunk-11-1.png" width="100%" />

`emptyDrops()` computes Monte Carlo _p_-values, so it is important to set the random seed to obtain reproducible results.
The number of Monte Carlo iterations also determines the lower bound for the _p_values.
If any non-significant barcodes are `TRUE` for `Limited`, we may need to increase the number of iterations to ensure that they can be detected.


```r
table(Sig=e.out$FDR <= 0.01, Limited=e.out$Limited)
```

```
##        Limited
## Sig     FALSE TRUE
##   FALSE   542    0
##   TRUE   2272 1623
```

We then subset our `SingleCellExperiment` object to retain only the detected cells.


```r
# using which() to automatically remove NAs.
sce <- sce[,which(e.out$FDR <= 0.01)]
```

<div class="alert alert-warning">
**Exercise:** 


```r
# How could I get all cells above the knee point?
keep <- br.out$total >= br.out$knee
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical  734523    2757
```


```r
# How can I recapitulate _CellRanger_'s cell calling?
cr.keep <- defaultDrops(counts(sce), expected=3000)
summary(cr.keep)
```

```
##    Mode   FALSE    TRUE 
## logical     632    3263
```


```r
# What does table() do with two variables?
fruits <- sample(c("Apple", "Banana", "Cucumbers"), 10, replace=TRUE)
people <- sample(c("Alex", "Brett", "Cameron"), 10, replace=TRUE)
table(fruits, people)
```

```
##            people
## fruits      Alex Brett Cameron
##   Apple        1     2       1
##   Banana       0     1       2
##   Cucumbers    0     3       0
```
</div>

# Quality control on the cells

It is possible for non-empty droplets to contain damaged or dying cells, which need to be removed prior to downstream analysis.
We compute some QC metrics using `calculateQCMetrics()` and examine their distributions:


```r
sce <- calculateQCMetrics(sce, feature_controls=list(Mito=which(location=="MT")))
par(mfrow=c(1,3))
hist(sce$log10_total_counts, breaks=20, col="grey80",
    xlab="Log-total UMI count")
hist(sce$log10_total_features_by_counts, breaks=20, col="grey80",
    xlab="Log-total number of expressed features")
hist(sce$pct_counts_Mito, breaks=20, col="grey80",
	xlab="Proportion of reads in mitochondrial genes")
```

<img src="answers_files/figure-html/unnamed-chunk-17-1.png" width="100%" />

We remove cells with low library sizes, low total number of expressed features or high mitochondrial proportions.
The last is a proxy for cell damage in the absence of spike-in RNA.


```r
low.lib <- isOutlier(sce$log10_total_counts, nmads=3, type="lower")
low.nfeat <- isOutlier(sce$log10_total_features_by_counts, nmads=3, type="lower")
high.mito <- isOutlier(sce$pct_counts_Mito, nmads=3, type="higher")
discard <- low.lib | low.nfeat | high.mito
data.frame(LowLib=sum(low.lib), LowNFeat=sum(low.nfeat), 
    HighMito=sum(high.mito), discard=sum(discard))
```

```
##   LowLib LowNFeat HighMito discard
## 1    675      666      578     747
```

We subset the `SingleCellExperiment` object to remove the low-quality cells.


```r
sce <- sce[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    3148     747
```

Outlier-based QC requires some care in heterogeneous datasets, where particular cell types might naturally express fewer features.
In this case, the population should be fairly homogeneous (all T cells) so we don't have to worry too much.

# Examining gene expression

The average expression of each gene is much lower here compared to the read count data set, due to:

- the reduced coverage per cell when thousands of cells are multiplexed together for sequencing.
- the collapsing of multiple reads from PCR amplicons of the same transcript into a single UMI.


```r
ave <- calcAverage(sce)
rowData(sce)$AveCount <- ave
hist(log10(ave), col="grey80")
```

<img src="answers_files/figure-html/unnamed-chunk-20-1.png" width="100%" />

The set of most highly expressed genes is dominated by ribosomal protein and mitochondrial genes, as expected.


```r
plotHighestExprs(sce)
```

<img src="answers_files/figure-html/unnamed-chunk-21-1.png" width="100%" />

# Normalizing for cell-specific biases

We perform some pre-clustering to break up obvious clusters and avoid pooling cells that are very different.
The `min.mean=` argument just avoids using genes with lots of zero counts.


```r
library(scran)
clusters <- quickCluster(sce, method="igraph", min.mean=0.1)
table(clusters)
```

```
## clusters
##    1    2 
## 1359 1789
```

We then apply the deconvolution method to compute size factors for all cells.


```r
sce <- computeSumFactors(sce, min.mean=0.1, cluster=clusters)
summary(sizeFactors(sce))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.3329  0.7960  0.9293  1.0000  1.0808 11.8380
```

The size factors are well correlated against the library sizes, indicating that capture efficiency and sequencing depth are the major biases.


```r
plot(sce$total_counts, sizeFactors(sce), log="xy")
```

<div class="figure">
<img src="answers_files/figure-html/sfplot-1.png" alt="Size factors for all cells in the PBMC dataset, plotted against the library size." width="100%" />
<p class="caption">(\#fig:sfplot)Size factors for all cells in the PBMC dataset, plotted against the library size.</p>
</div>

Finally, we compute normalized log-expresion values.
There is no need to call `computeSpikeFactors()` here, as there are no spike-in transcripts available.


```r
sce <- normalize(sce)
assayNames(sce)
```

```
## [1] "counts"    "logcounts"
```

<div class="alert alert-warning">
**Exercise:** 


```r
# What do we do about negative size factors?
lib.factors <- librarySizeFactors(sce)
is.neg <- sizeFactors(sce) < 0
sizeFactors(sce)[is.neg] <- lib.factors[is.neg]
```
</div>


# Modelling the mean-variance trend

We don't have spike-ins, so we can't directly model the technical noise.
One option is to assume that most genes do not exhibit strong biological variation, and to fit a trend to the variances of endogenous genes.


```r
fit <- trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))
plot(fit$mean, fit$var, pch=16, xlab="Mean log-exression",
	ylab="Variance of log-expression")
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<img src="answers_files/figure-html/unnamed-chunk-26-1.png" width="100%" />

Another option is to assume that the technical noise is Poisson and create a fitted trend on that basis using the `makeTechTrend()` function.


```r
new.trend <- makeTechTrend(x=sce)
plot(fit$mean, fit$var, pch=16,  xlab="Mean log-exression",
	ylab="Variance of log-expression")
curve(new.trend(x), col="red", add=TRUE)
```

<img src="answers_files/figure-html/unnamed-chunk-27-1.png" width="100%" />

Assuming Poisson noise, we decompose the total variance to its technical and biological components:


```r
fit$trend <- new.trend # tricking decomposeVar into thinking this is the trend!
dec <- decomposeVar(fit=fit)
top.dec <- dec[order(dec$bio, decreasing=TRUE),]
head(top.dec)
```

```
## DataFrame with 6 rows and 6 columns
##                     mean            total               bio
##                <numeric>        <numeric>         <numeric>
## CCL5   0.866739857997132 1.87484547069157  1.32506876873723
## JUNB     3.4232198752903 1.50006371638144  1.27712383213415
## S100A4   2.0227251520207 1.58285537030451  1.06170243994199
## KLRB1  0.736603991564056  1.5360462457721  1.02808303353067
## GNLY   0.578686736972986 1.45771630304116  1.01799752744899
## JUN     2.37743664893431 1.43222413308213 0.992471814944436
##                     tech   p.value       FDR
##                <numeric> <numeric> <numeric>
## CCL5   0.549776701954339         0         0
## JUNB   0.222939884247295         0         0
## S100A4 0.521152930362521         0         0
## KLRB1  0.507963212241431         0         0
## GNLY   0.439718775592171         0         0
## JUN    0.439752318137697         0         0
```

We have a look at the genes with the largest biological components.


```r
plotExpression(sce, features=rownames(top.dec)[1:10])
```

<img src="answers_files/figure-html/unnamed-chunk-29-1.png" width="100%" />

# Dimensionality reduction

We use the `denoisePCA()` function with the assumed Poisson technical trend, to choose the number of dimensions to retain after PCA.
Note the `approx=TRUE`, which uses *[irlba](https://CRAN.R-project.org/package=irlba)* to perform a fast PCA.


```r
sce <- denoisePCA(sce, technical=new.trend, approx=TRUE)
ncol(reducedDim(sce, "PCA"))
```

```
## [1] 26
```

Examination of the first few PCs already reveals two clear clusters in the data:


```r
plotPCA(sce, ncomponents=3, colour_by="log10_total_features_by_counts")
```

<img src="answers_files/figure-html/unnamed-chunk-31-1.png" width="100%" />

This is recapitulated with a _t_-SNE plot _on the PCs_, see the use of `use_dimred=`.


```r
sce <- runTSNE(sce, use_dimred="PCA", perplexity=30, rand_seed=100)
plotTSNE(sce, colour_by="log10_total_features_by_counts")
```

<img src="answers_files/figure-html/unnamed-chunk-32-1.png" width="100%" />

<div class="alert alert-warning">
**Exercise:** 


```r
# How do we check the percentage of variance explained?
plot(attr(reducedDim(sce), "percentVar"), xlab="PC",
	ylab="Proportion of variance explained")
abline(v=ncol(reducedDim(sce, "PCA")), lty=2, col="red")
```

<img src="answers_files/figure-html/unnamed-chunk-33-1.png" width="100%" />
</div>

# Clustering with graph-based methods

We start by building a shared nearest neighbour graph, where each cells is connected to its neighbours by an edge.
Unlike hierarchical clustering, we do not need to construct a distance matrix for a large number of cells.


```r
snn.gr <- buildSNNGraph(sce, use.dimred="PCA")
snn.gr
```

```
## IGRAPH e4a4244 U-W- 3148 226300 -- 
## + attr: weight (e/n)
## + edges from e4a4244:
##  [1] 1--  20 1--  46 1--  98 1-- 106 1-- 196 1-- 356 1-- 374 1-- 400 1-- 440
## [10] 1-- 446 1-- 452 1-- 497 1-- 531 1-- 571 1-- 586 1-- 590 1-- 592 1-- 607
## [19] 1-- 642 1-- 721 1-- 741 1-- 767 1-- 817 1-- 849 1-- 878 1-- 922 1-- 973
## [28] 1--1085 1--1090 1--1102 1--1194 1--1227 1--1264 1--1290 1--1310 1--1433
## [37] 1--1449 1--1488 1--1500 1--1515 1--1522 1--1542 1--1550 1--1579 1--1593
## [46] 1--1598 1--1634 1--1653 1--1722 1--1765 1--1777 1--1828 1--1906 1--1963
## [55] 1--1995 1--2018 1--2029 1--2031 1--2037 1--2056 1--2075 1--2094 1--2167
## [64] 1--2216 1--2252 1--2273 1--2278 1--2323 1--2362 1--2365 1--2366 1--2399
## + ... omitted several edges
```

We then use the Walktrap algorithm to identify clusters, i.e., "communities" in the graph.
These are groups of cells that are highly connected within each group, which relatively few connections between groups.


```r
clusters <- igraph::cluster_walktrap(snn.gr)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)
```

```
## 
##   1   2   3   4   5   6   7   8   9  10 
## 210 353 780 336  20  34  50 872 111 382
```

We examine the "modularity" of the clusters, i.e., how enriched a cluster is for intra-group connections relative to what is expected under a null model.
At least a few of the clusters are not very modular (strong off-diagonal entries) - not surprising for T cell subsets.


```r
cluster.mod <- clusterModularity(snn.gr, sce$Cluster, get.values=TRUE)
log.ratio <- log2(cluster.mod$observed/cluster.mod$expected + 1)

library(pheatmap)
pheatmap(log.ratio, cluster_rows=FALSE, cluster_cols=FALSE, 
    color=colorRampPalette(c("white", "blue"))(100))
```

<img src="answers_files/figure-html/unnamed-chunk-36-1.png" width="100%" />

We examine the cluster identities on a _t_-SNE plot:


```r
plotTSNE(sce, colour_by="Cluster")
```

<img src="answers_files/figure-html/unnamed-chunk-37-1.png" width="100%" />

<div class="alert alert-warning">
**Exercise:** 


```r
# Why did I use igraph::? 
library(igraph)
normalize
```

```
## function (xmin = -1, xmax = 1, ymin = xmin, ymax = xmax, zmin = xmin, 
##     zmax = xmax) 
## {
##     args <- grab_args()
##     layout_modifier(id = "normalize", args = args)
## }
## <bytecode: 0x3d1927d8>
## <environment: namespace:igraph>
```
</div>

# Marker gene detection

We detect marker genes for each cluster using `findMarkers()`.
We only look at upregulated genes in each cluster, as these are more useful for positive identification of cell types in a heterogeneous population.


```r
markers <- findMarkers(sce, clusters=sce$Cluster, direction="up")
```

We examine the markers for cluster 9 in more detail.


```r
marker.set <- markers[["9"]]
head(marker.set, 10) 
```

```
## DataFrame with 10 rows and 11 columns
##              Top                  FDR            logFC.1           logFC.2
##        <integer>            <numeric>          <numeric>         <numeric>
## CCL5           1 1.35571776191053e-93  0.299503521296469  3.40769540463458
## NKG7           1 3.58783922891146e-91   1.36240873433019  3.68583090468534
## GNLY           1 1.09092990619759e-80   1.81033675688683  3.89278636557171
## GZMH           1 1.50696931178594e-52   1.93955152517173  2.39583911109895
## NR4A2          1 1.00490085513719e-17   0.24896234769308 0.962836203951776
## FGFBP2         2  1.1200174028583e-34   1.52947400071519  1.67814241954785
## NFKBIA         2 1.12298208204903e-15 -0.416902561124387 0.956997336621619
## S100A4         3 6.37128458494299e-72  0.305523229423491  2.05824641246928
## JUNB           3 1.96241476137119e-13 -0.160286112603715 0.896368221362048
## HLA-B          4 4.23055781588675e-64  0.248788044486981 0.871839289668576
##                    logFC.3           logFC.4           logFC.5
##                  <numeric>         <numeric>         <numeric>
## CCL5      2.87197545966007   2.6085315064624  3.55586120533402
## NKG7       3.5903251460287  3.55914489547306  3.52863383333417
## GNLY      3.76968841666717  3.72664526129715  3.88291089049325
## GZMH      2.39279780410589  2.40996929372838  2.36758170942541
## NR4A2  -0.0444081306136161 0.859263607361854 0.448520832862128
## FGFBP2    1.69465058278613   1.7083673365335   1.6742713648862
## NFKBIA  -0.596958273738673 0.666470186247867 0.320312255159684
## S100A4   0.500399710484244 0.255891021313823  1.57401825769147
## JUNB    -0.682527727221608 0.552221506713604 0.769684488931648
## HLA-B    0.726722859421497 0.632881322157227  1.50888983826696
##                  logFC.6             logFC.7             logFC.8
##                <numeric>           <numeric>           <numeric>
## CCL5    3.24248332012342  -0.238611369485005    3.52317132803508
## NKG7     3.3749908046408  0.0402736502211583    3.66683693591061
## GNLY    3.89596099558442   0.445310552149588    3.90607928515039
## GZMH    2.28496770713443   0.129424697758096    2.40341262514359
## NR4A2   1.03499767742804    1.11595672048672 -0.0337515518142997
## FGFBP2  1.65791083072441   0.272054992151401    1.70170204894078
## NFKBIA 0.774456110085071    1.31359399485157  -0.103145555811661
## S100A4 0.130115329804307   0.168273443902509    2.03799496436042
## JUNB    1.30437493178583    1.79202090707657  -0.782712157129713
## HLA-B  0.830757109230738 0.00167740211102707   0.869476509429505
##                  logFC.10
##                 <numeric>
## CCL5     3.44996096588923
## NKG7     3.65343340251918
## GNLY     3.92902943464824
## GZMH     2.41081951315912
## NR4A2  -0.135778659349081
## FGFBP2   1.69053012974944
## NFKBIA 0.0491395123086693
## S100A4    2.0564527510763
## JUNB   -0.641864655863407
## HLA-B   0.843945206336727
```

The transcriptional profile of cluster 9 is clearly distinct from the others:


```r
chosen <- rownames(marker.set)[marker.set$Top <= 10]
plotHeatmap(sce, features=chosen, exprs_values="logcounts", 
    zlim=3, center=TRUE, symmetric=TRUE, cluster_cols=FALSE,
    colour_columns_by="Cluster", columns=order(sce$Cluster))
```

<img src="answers_files/figure-html/unnamed-chunk-41-1.png" width="100%" />

... which can be further examined on the _t_-SNE plot:


```r
plotTSNE(sce, colour_by="GNLY")
```

<img src="answers_files/figure-html/unnamed-chunk-42-1.png" width="100%" />

So, these are probably cytotoxic T cells, with some Jun/Fos activity. 

<div class="alert alert-warning">
**Exercise:** 


```r
# What's cluster 8? How is it different from 3 and 10?
marker.set2 <- markers[["8"]]
chosen <- rownames(marker.set2)[marker.set2$Top <= 10]
plotHeatmap(sce, features=chosen, exprs_values="logcounts", 
    zlim=3, center=TRUE, symmetric=TRUE, cluster_cols=FALSE,
    colour_columns_by="Cluster", columns=order(sce$Cluster))
```

<img src="answers_files/figure-html/unnamed-chunk-43-1.png" width="100%" />


```r
# Try looking at all genes in both directions:
markers2 <- findMarkers(sce, clusters=sce$Cluster)
marker.set2 <- markers2[["8"]]
chosen <- rownames(marker.set2)[marker.set2$Top <= 10]
plotHeatmap(sce, features=chosen, exprs_values="logcounts", 
    zlim=3, center=TRUE, symmetric=TRUE, cluster_cols=FALSE,
    colour_columns_by="Cluster", columns=order(sce$Cluster))
```

<img src="answers_files/figure-html/unnamed-chunk-44-1.png" width="100%" />

Check out _CD7_, _CD8_, _S100A4_.
</div>

# Concluding remarks

Having completed the basic analysis, we save the `SingleCellExperiment` object with its associated data to file.
This avoids having to repeat all of the pre-processing steps described above prior to further analyses.


```r
saveRDS(sce, file="t3k_data.rds")
```

See https://www.bioconductor.org/packages/devel/workflows/vignettes/simpleSingleCell/inst/doc/work-3-tenx.html for more details.

Meanwhile, show the session information for record-keeping:


```r
sessionInfo()
```

```
## R version 3.5.0 Patched (2018-04-30 r74681)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.5 LTS
## 
## Matrix products: default
## BLAS: /home/cri.camres.org/lun01/Software/R/R-3-5-branch-release/lib/libRblas.so
## LAPACK: /home/cri.camres.org/lun01/Software/R/R-3-5-branch-release/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
##  [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
##  [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] igraph_1.2.2                pheatmap_1.0.10            
##  [3] scran_1.8.4                 EnsDb.Hsapiens.v86_2.99.0  
##  [5] ensembldb_2.4.1             AnnotationFilter_1.4.0     
##  [7] GenomicFeatures_1.32.2      AnnotationDbi_1.42.1       
##  [9] scater_1.8.4                ggplot2_3.0.0              
## [11] Matrix_1.2-14               DropletUtils_1.0.3         
## [13] SingleCellExperiment_1.2.0  SummarizedExperiment_1.10.1
## [15] DelayedArray_0.6.5          matrixStats_0.54.0         
## [17] Biobase_2.40.0              GenomicRanges_1.32.6       
## [19] GenomeInfoDb_1.16.0         IRanges_2.14.11            
## [21] S4Vectors_0.18.3            BiocGenerics_0.26.0        
## [23] BiocParallel_1.14.2         knitr_1.20                 
## [25] BiocStyle_2.8.2            
## 
## loaded via a namespace (and not attached):
##  [1] Rtsne_0.13               ggbeeswarm_0.6.0        
##  [3] colorspace_1.3-2         rjson_0.2.20            
##  [5] dynamicTreeCut_1.63-1    rprojroot_1.3-2         
##  [7] XVector_0.20.0           DT_0.4                  
##  [9] bit64_0.9-7              tximport_1.8.0          
## [11] Rsamtools_1.32.3         shinydashboard_0.7.0    
## [13] shiny_1.1.0              compiler_3.5.0          
## [15] httr_1.3.1               backports_1.1.2         
## [17] assertthat_0.2.0         lazyeval_0.2.1          
## [19] limma_3.36.2             later_0.7.3             
## [21] htmltools_0.3.6          prettyunits_1.0.2       
## [23] tools_3.5.0              bindrcpp_0.2.2          
## [25] gtable_0.2.0             glue_1.3.0              
## [27] GenomeInfoDbData_1.1.0   reshape2_1.4.3          
## [29] dplyr_0.7.6              Rcpp_0.12.18            
## [31] Biostrings_2.48.0        rtracklayer_1.40.5      
## [33] DelayedMatrixStats_1.2.0 xfun_0.3                
## [35] stringr_1.3.1            mime_0.5                
## [37] irlba_2.3.2              statmod_1.4.30          
## [39] XML_3.98-1.16            edgeR_3.22.3            
## [41] zlibbioc_1.26.0          scales_1.0.0            
## [43] hms_0.4.2                promises_1.0.1          
## [45] ProtGenerics_1.12.0      rhdf5_2.24.0            
## [47] RColorBrewer_1.1-2       yaml_2.2.0              
## [49] curl_3.2                 memoise_1.1.0           
## [51] gridExtra_2.3            biomaRt_2.36.1          
## [53] stringi_1.2.4            RSQLite_2.1.1           
## [55] highr_0.7                rlang_0.2.2             
## [57] pkgconfig_2.0.2          bitops_1.0-6            
## [59] evaluate_0.11            lattice_0.20-35         
## [61] purrr_0.2.5              Rhdf5lib_1.2.1          
## [63] bindr_0.1.1              GenomicAlignments_1.16.0
## [65] htmlwidgets_1.2          labeling_0.3            
## [67] cowplot_0.9.3            bit_1.1-14              
## [69] tidyselect_0.2.4         plyr_1.8.4              
## [71] magrittr_1.5             bookdown_0.7            
## [73] R6_2.2.2                 DBI_1.0.0               
## [75] pillar_1.3.0             withr_2.1.2             
## [77] RCurl_1.95-4.11          tibble_1.4.2            
## [79] crayon_1.3.4             rmarkdown_1.10          
## [81] viridis_0.5.1            progress_1.2.0          
## [83] locfit_1.5-9.1           grid_3.5.0              
## [85] data.table_1.11.4        blob_1.1.1              
## [87] FNN_1.1.2.1              digest_0.6.16           
## [89] xtable_1.8-2             httpuv_1.4.5            
## [91] munsell_0.5.0            beeswarm_0.2.3          
## [93] viridisLite_0.3.0        vipor_0.4.5
```

